---
categories: 算法
title: 算法知识集锦
---

# 大整数问题

## 大整数结构体在C++中的实现

### 基本表示

结构体`BigInteger`能够存储高精度非负整数。其基本实现方式如下：

```c++
struct BigInteger {
	static const int BASE = 100000000; //静态成员变量使得其可以被所有实例访问，且只有一份
	static const int WIDTH = 8; //vector中的每一位都代表着一亿
	vector<int> s; //每一位表示一个八位的整数，若是要表示1234,则s={4,3,2,1}
    
	BigInteger(long long num = 0) {
        *this = num;
    } //构造函数
};
```

### 重载赋值运算符

可以重载赋值运算符`=`来对其进行赋值。

```c++
BigInteger operator = (long long num) { //对于长整数类型的赋值运算符
	s.clear();
	do {
		s.push_back(num % BASE);
		num /= BASE;
	} while(num > 0);
	return *this;
}

BigInteger operator = (const string& str) { //对于字符串类型的赋值运算符
	s.clear();
	int x, len = (str.length() - 1) / WIDTH + 1;
	for(int i = 0; i < len; i++) {
		int end = str.length() - i*WIDTH;
		int start = max(0, end - WIDTH);
		sscanf(str.substr(start, end-start).c_str(), "%d", &x);
		s.push_back(x);
	}
    return *this;
}
```

# 排序问题

## 希尔排序

希尔排序，也称递减增量排序算法，是**插入排序**的一种更高效的改进版本。希尔排序是**非稳定**排序算法。希尔排序按其设计者希尔（Donald Shell）的名字命名，该算法由1959年公布。一些老版本教科书和参考手册把该算法命名为`Shell-Metzner`，即包含`Marlene Metzner Norton`的名字，但是根据`Metzner`本人的说法，“我没有为这种算法做任何事，我的名字不应该出现在算法的名字中。”

### 前提

希尔排序基于插入排序的以下两点性质而提出改进的方法：

1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。

### 算法思想

将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用$i= i +  stepsize$而不是$i++$。

例如，假设有这样一组数`[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]`，如果我们以步长为`5`开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 

```c++
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序： 

```c++
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：`[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]`.然后再以`3`为步长进行排序： 

```c++
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为： 

```c++
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）。 

### 步长序列

步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为`1`时，算法变为直接的插入排序，这就保证了数据一定会被排序。



# 树

## 二叉树

### 性质

- 深度为$h$的二叉树最多有$2^h-1$个节点，最少有$h$个节点；



## 红黑树

红黑树是一种平衡二叉查找树。这意味着红黑树**既有着平衡的性质，也有着能够查找（搜索）的性质**。红黑树属于平衡二叉树，**但它不是严格平衡的。** 严格的平衡二叉树要求左右子树的高度差为1，而红黑树不是。所以从严格性上来排序的话，能够得到以下顺序：**二叉查找树<红黑树<平衡二叉查找树。**

### 性质

红黑树是**每个节点都带有颜色属性的二叉查找树**，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是`NIL`节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点）。
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。(具有相同的黑高)。

以下即为一棵红黑树：

![](C:/Users/Tristone/Documents/GitHub/tristone13th.github.io/img/RBT.png)

### 对于性质的分析

这些约束确保了红黑树的关键特性：**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树大致上是**平衡**的。

操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在**最坏情况下都是高效**的，而不同于普通的二叉查找树。 

### 红黑树的高效性保持

根据`性质5`，我们可以得到任意两条路径的黑高相同，即他们的黑色节点数相同。根据`性质4`，因为任意一条路径的红色节点出现必须与黑色节点交叉出现，而黑色节点可以单独出现，我们可以得到任意一条路径的红色节点数目小于黑色节点的数目。因此，**任意两条路径之间的差距不可能大于一倍。**

# Tricks

## 输入输出C++框架

### 标准流中的输入输出

在C语言中，代码

```c++
scanf("%d", &x);
```

的返回值是一个正确输入的个数，如上面的这个代码若执行成功，则返回值为1。

由此，当系统中未指定要输入元素的个数时，我们可以使用以下代码来进行赋值

```c++
while(scanf("%d", &x) == 1){} 
```

从而进行有效的赋值。

### 文件流中的输入输出

使用文件最简单的方法是使用输入输出重定向，只需在`main`函数的入口处加入以下两条语句：

```c++
freopen("input.txt", "r", stdin); 
freopen("output.txt", "w", stdout);
```

上述语句将使得`scanf`从文件`input.txt`读入，`printf`写入文件`output.txt`。事实上，不只是`scanf` 和`printf`，所有读键盘输入、写屏幕输出的函数都将改用文件。

有一种方法可以在本机测试时用文件重定向，但一旦提交到比赛，就自动删除重定向语句。

```c++
#define LOCAL 
#include<stdio.h> 
#define INF 1000000000
int main() {
    #ifdef LOCAL  
        freopen("data.in", "r", stdin);  
        freopen("data.out", "w", stdout); 
    #endif  
    int x, n = 0, min = INF, max = -INF, s = 0;  
    while(scanf("%d", &x) == 1) {
        //Here to write the logic statement;
    }
}
```

在提交时删除宏定义语句即可。

## 提前取余

要计算只包含加法、减法和乘法的整数表达式除以正整数$n$的余数，可以在每步计算之后对$n$取余，结果不变。

### 证明

证明过程可以分为以下三点：

- 和的余数等于余数的和；
- 差的余数等于余数的差；
- 积的余数等于余数的积。

首先证明**和的余数等于余数的和**：

假设有两个数$x$和$y$，可以将它们写成如下形式：


$$
x=a_{1}\times n+b_{1}\\
y=a_{2}\times n+b_{2}
$$


那么它们的和为：


$$
x+y=(a_{1}+a_{2})\times n+(b_{1}+b_{2})
$$


$x$对于$n$取余的余数为$b_{1}$，$y$对于$n$取余的余数为$b_{2}$，$x+y$对于$n$取余的余数为$b_{1}+b_{2}$，两者相等，故**和的余数等于余数的和**。

其次证明**差的余数等于余数的差**：

同上，它们的差为：


$$
x-y=(a_{1}-a_{2})\times n+(b_{1}-b_{2})
$$


$x-y$对于$n$取余的余数为$b_{1}-b_{2}$，故**差的余数等于余数的差**。

最后证明**积的余数等于余数的积**：

同上，它们的积为：


$$
x\times y=a_{1}a_{2}n^{2}+\left( a_{1}b_{2}+a_{2}b_{1} \right)n+b_{1}b_{2}
$$


其对于$n$的余数为$b_{1}b_{2}$，正好等于两者余数的积。



