---
categories: Haskell
title: Some notes in Haskell
---

# Functor

### `Instance Functor Maybe` or `Instance Functor (Maybe m)`?

*Functor* is a special *type class*, for we define Functor type class as:

```haskell
class Functor f where 
	fmap :: (a -> b) -> f a -> f b
```

In classical *type classes*, which is defined such as following:

```haskell
class Eq a where 
	(==) :: a -> a -> Bool 
	(/=) :: a -> a -> Bool 
	x == y = not (x /= y) 
	x /= y = not (x == y)
```

there *a* denotes a *type variable* which can be think as `Int`, `Double`, `Char` and so on. When we implement this type class, we use `instance` clause such as following:

```haskell
instance Eq TrafficLight where 
	Red == Red = True 
	Green == Green = True 
	Yellow == Yellow = True 
	_ == _ = False
```

where `TrafficLight` is a *concrete type*, 

Think of that a functor is also a type class, when we implement functor type class, we use following statements:

```haskell
instance Functor Maybe where 
	fmap f (Just x) = Just (f x) 
	fmap f Nothing = Nothing
```

**Question 1**: When we implement the `Eq` type class, we use a concrete type `TrafficLight`; but when we implement the `Functor` type class, why we can use `Maybe` which is just a *type constructor* and not a type?

**Answer**: Just as an answer in Stack Overflow question [What is a functor in functional programming](https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor), we can just think `Maybe` as a more general type with some collective properties, it can take a type such as `Int` as its parameters and generate a new type `Maybe Int`, which is a concrete type not so general as type `Maybe` is.

So the right answer is `Instance Functor Maybe`.

### How to understand `Function as Functor` and `Function as Applicative`?

First, how to understand function as functor?

We can regard functor as an empty box such as:

```haskell
instance Functor Maybe where 
	fmap :: (a -> b) -> f a -> f b
	fmap f (Just x) = Just (f x) 
	fmap f Nothing = Nothing
```

there, `Maybe` type can be seen as an **empty box with one slot** which take a type to generate a concrete type `Maybe a`. In the `fmap` function:

- The first parameter is a function, which maps from a to b;
- **The second parameter is a concrete type, which is generated by type constructor and has the type *f a* (*f* is `Maybe`, so *f a* is `Maybe a` ).**

When we implement function functors, for function functors must have two parameters to make a type `a -> b`, if we want our function functor has one slot, we should first fill a slot, so the type constructor of function functor is ((->) r):

```haskell
instance Functor ((->) r) where 
	fmap f g = (\x -> f (g x))
```

As the same as the `fmap` function in `Maybe` Functor, we should regard the second parameter *g* as a concrete type which is generate by *f* (*f* equals `(->) r`), so *f a* is `(->) r a` which can be seen as `r -> a`. Finally, it is not difficult to understand that the *g x* in the `fmap` function cannot be seen as `r -> x`,  it is just a function application which can be seen as `(r -> a) x`, also `(x -> a)`.

Finally, it is not hard to understand that the <\*> function in Applicative function `(->) r`  can be implemented as following:

```haskell
<*> :: f (a -> b) -> f a -> f b
<*> :: (r -> a -> b) -> (r -> a) -> (r -> b)
<&> :: (a -> b) -> (r -> a) -> (r -> b)
f <*> g = \r -> f r (g r)
```

for *g r* will map *r* to *a*, *f r a* will map *r, a* to *b*, so the whole lambda function can be seen as `r -> b`,  also `f b`. For an instance:

```haskell
((+) <*> (+3)) 5
```

the result is 5 + (5 + 3) = 13.

# Applicative Functor

### How to understand in functions as applicatives, `(+) <$> (+3) <*> (*100) $ 5 ` = 508?

We know `(+)` has type: `Num a, a -> a -> a`;

We also know `(+3)` and `(*100)`has type: `Num r, a, r -> a`;

`(+) <$> (+3)` equals `pure (+) <*> (+3)`, where `:t pure (+)` equals `Num r, a, r -> a -> a -> a`

In another words, the `pure (+)` maps the return value of function `(+3)` to a function, for

```haskell
f <*> g = \r -> f r (g r)
```

we can apply the operators and get:

```haskell
pure (+) <*> (+3) = \r x -> (r + 3) + x 
```

it has the type `r -> x -> a`. We then calculate `pure (+) <*> (+3) <*> (*100)` using the definition of <*>, and get:

```haskell
pure (+) <*> (+3) <*> (*100) = \r -> (r + 3) + (r * 100)
```

then we apply this function with parameter 5, we get:

```haskell
(5 + 3) + (5 * 100) = 508 
```







