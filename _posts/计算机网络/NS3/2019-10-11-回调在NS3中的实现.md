---
categories: NS3
title: 回调在NS3中的实现
---

NS3中使用了Functor机制，也就是函子机制来完成回调的实现，具体如下：

首先是Functor类与SpecialFunctor类的实现：

```c++
#include <iostream>

using namespace std;

template <typename T>
class Functor {
 public:
  // The overload for operator ()
  virtual void operator()(T arg) = 0;
};

template <typename T, typename ARG>
class SpecificFunctor : public Functor<ARG> {
 public:
  SpecificFunctor(T *p, void (T::*_pmi)(ARG arg)) {
    m_p = p;
    m_pmi = _pmi;
  }
  virtual void operator()(ARG arg) { (*m_p.*m_pmi)(arg); }

 private:
  void (T::*m_pmi)(ARG arg);
  T *m_p;
};

class A {
 public:
  A(int a0) : a(a0) {}
  void Hello(int b0) {
    std::cout << "Hello from A, a = " << a << " b0 = " << b0 << std::endl;
  }
  int a;
};

int main() {
  A a(10);
  SpecificFunctor<A, int> sf(&a, &A::Hello);
  sf(5);
}
```

在这段代码中，首先定义一个Functor类，用来支持后面**函数多态**的机制，后面使用了一个SpecificFunctor类来支持将**不同的类，及有着不同类型参数的函数**用于初始化该实例。

假如我们要在一个函数中进行函数的回调，便可以如此实现：

```c++
void LibraryFunction (Functor functor) {
// Execute the library function 
	functor(1234);
}
```

这样就对调用者和被调用者之间实现了解耦，我们可以在做完该函数的功能后回调函数functor中绑定的函数。

