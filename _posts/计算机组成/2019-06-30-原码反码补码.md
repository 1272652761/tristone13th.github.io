---
categories: 计算机组成
title: 源码、反码与补码
---

# 原码

## 原码规则

把左边第一位腾出位置，用来存放符号。正号用0来表示，负号用1来表示。这种表示**对人类友好，但是对于计算机不友好**。其有以下几个缺点：

- 可以进行表示，但是**无法进行运算**。两个用原码表示的数字用自然规则进行运算，得到的结果不一定是正确的；
- 存在两个0，即正0与负0，这是一种对于编码的浪费。

# 反码

## 反码规则

反码对于正数的表示规则相对于原码没有改变，但是负数上进行了改变，即符号位仍然是1，但是其余各位取反。

`反码的出现解决了正负相加等于0的问题：每一对正负数相加正好等于全1，在反码的表示规则中，全1表示负0。`

但是存在两个0的问题仍然没有得到解决。

# 补码

## 补码规则

补码的表示**对人类不友好，但是对于计算机友好**。我们希望只有一个0，所以发明了"补码"。"补码"的意思是，从原来"反码"的基础上，补充一个新的代码（+1），这样便完美地消除掉了负0，并且也空出了一个编码用来表示一个新的数字。

# 三种编码的比较

三种编码的区别如下图所示。

![](../../img/forms.png)

## 运算的比较

这里对三种编码的运算做一个比较：这种比较是基于四则运算的，且比较的`前置条件`是**两个运算数的表示值的理论上的运算结果应当位于编码的表示区间内**。下面的以上图中**八个二进制位**为例来进行阐释。

### 码的加法规则

从末位开始相加，依次向前进位，若最高位有进位则简单地将其丢弃。

### 码的减法规则

按照**减去一个数=加上这个数的负数**原则，我们首先定义如何得到一个码的负表示，**即不论一个码是正码还是负码，皆各位取反后加一，将此码定义为其负数的码**。

事实上，只有补码按照该规则取到的码才为正确的该数负数的码，其他（原码、反码）按照此方式皆为错误的码。

### 正数相加

为了保证满足以上前置条件，正数相加的范围是**理论结果值不大于127**。设符号$c$为码值，$$r$$为表示值。

- **原码**：从图中可以看出，由于码值与表示值在正数范围内呈线性关系，即$r=\alpha \times c$ ，其中$\alpha$为系数，值为1。设$r_{1}=\alpha \times c_{1}$，$r_{2}=\alpha \times c_{2}$，则容易得到：
  $$
  r_{1}+r_{2}=\alpha \times c_{1}+\alpha \times c_{2}=\alpha \times(c_{1}+c_{2})
  $$
  该式表明，两个编码值相加后的结果的表示值仍然**正确**。

- **反码**：反码的正数部分与原码相同，故**同上**；

- **补码**：补码的正数部分与原码相同，故**同上**；

### 正负相加得正

### 正负相加得负

### 负负相加

### 为什么不讨论相减的情况

因为所有相减的情况都可以通过负数变换得到以上四种情况之一，故没有必要探讨相减的情况。 